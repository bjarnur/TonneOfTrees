#version 330 core
out vec4 FragColor;
  
in vec2 TexCoords;
in vec3 CameraRight;
in vec3 CameraUp;

uniform vec3 weights;
uniform vec3 up0;
uniform vec3 up1;
uniform vec3 up2;
uniform vec3 up3;
uniform vec3 normal0;
uniform vec3 normal1;
uniform vec3 normal2;
uniform vec3 normal3;
uniform sampler2D screenTexture1;
uniform sampler2D screenTexture2;
uniform sampler2D screenTexture3;

/*
Given a 3D point and a sample plane (centered around origin with 
provided norm and up vectors), this function returns the 2D coordinates
resulted in projecting the point to the plane. 
*/
vec2 projectPointToSample(vec3 point, vec3 sampleNorm, vec3 sampleUp, float sampleDim)
{
	//Project point to sample plane
	float pointPlaneDist = dot(point, sampleNorm);
	vec3 projectedPos = (point - (sampleNorm * pointPlaneDist));

	//Get local sample coords
	vec3 sampleRight = -cross(sampleNorm, sampleUp);
	float c1 = (dot(projectedPos, sampleRight) + sampleDim/2) * sampleDim;
	float c2 = (dot(projectedPos, sampleUp) + sampleDim/2) * sampleDim;
	
	vec2 coords = vec2(c1, c2);
	return coords;
}


void main()
{ 
	//World-size of sample textures
    float sampleDim = 1.03696;

	//Sample coordinates
	float uCoord = (TexCoords.x * sampleDim) - sampleDim/2;
	float vCoord = (TexCoords.y * sampleDim) - sampleDim/2;

	//World position of sample coordinates
	vec3 worldPos = CameraRight * uCoord + CameraUp *  vCoord;

	vec2 coords1 = projectPointToSample(worldPos, normal1, up1, sampleDim);
	vec2 coords2 = projectPointToSample(worldPos, normal2, up2, sampleDim);
	vec2 coords3 = projectPointToSample(worldPos, normal3, up3, sampleDim);

	vec4 texColor1 = texture(screenTexture1, coords1);
	vec4 texColor2 = texture(screenTexture2, coords2);
	vec4 texColor3 = texture(screenTexture3, coords3);
	
	vec3 q = worldPos + 
	(weights.x * texColor1.x + weights.y * texColor2.x + weights.z * texColor3.x) * (1.0 * cross(CameraRight, CameraUp));
	coords1 = projectPointToSample(q, normal1, up1, sampleDim);
	coords2 = projectPointToSample(q, normal2, up2, sampleDim);
	coords3 = projectPointToSample(q, normal3, up3, sampleDim);

	texColor1 = texture(screenTexture1, coords1);
	texColor2 = texture(screenTexture2, coords2);
	texColor3 = texture(screenTexture3, coords3);

	vec3 pv = worldPos + 
	(weights.x * texColor1.x + weights.y * texColor2.x + weights.z * texColor3.x) * (1.0 * cross(CameraRight, CameraUp));

	vec4 texColor = (texColor1 * weights.x) + (texColor2 * weights.y) + (texColor3 * weights.z);

	//Why is this hack necessary?? Using only alpha discards some fragments that shouldn't be transparent!?
	if(texColor.r == 0.0 && texColor.g == 0.0 && texColor.b == 0.0 && texColor.a < 0.2)
		discard;
	texColor.a = 1;

	//Convenient for debugging
	/*	
	float c1 = coords1.x;
	float c2 = coords1.y;
	if(c1 > 1.0 || c2 > 1.0)
	{
		FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	}
	else if(c1 < 0.0 || c2 < 0.0)
	{
		FragColor = vec4(0.0, 1.0, 0.0, 1.0);
	}
	else
	{
		FragColor = texture(screenTexture1, vec2(c1, c2));
	}	
	*/
}